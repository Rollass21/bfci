!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALLOCFAIL	bfci.h	32;"	d
ALLOCJMP	bfci.h	24;"	d
ASSERT	bfci.h	60;"	d
BFCI_H	bfci.h	2;"	d
BIT_SET_FALSE	bfci.h	51;"	d
BIT_SET_TRUE	bfci.h	50;"	d
BIT_TOGGLE	bfci.h	49;"	d
CASE_FAIL	bfci.h	56;"	d
CASE_PASS	bfci.h	55;"	d
CC	makefile	/^CC = gcc # compiler used: gcc$/;"	m
CFLAGS	makefile	/^CFLAGS = -O0 -ggdb -Wall #-Werror$/;"	m
CTX_COMPLETED	bfci.h	/^    CTX_COMPLETED            = 1 <<  2,$/;"	e	enum:__anon2
CTX_RUNNING	bfci.h	/^    CTX_RUNNING              =       1,$/;"	e	enum:__anon2
DATAMAX	bfci.h	22;"	d
DATAMAXLEN	bfci.h	25;"	d
DATAMIN	bfci.h	23;"	d
DATA_ALLOW_LOOPED	bfci.h	/^    DATA_ALLOW_LOOPED        = 1 <<  5,  $/;"	e	enum:__anon2
DATA_ALLOW_OVERFLOW	bfci.h	/^    DATA_ALLOW_OVERFLOW      = 1 <<  6,  $/;"	e	enum:__anon2
DATA_ALLOW_UNDERFLOW	bfci.h	/^    DATA_ALLOW_UNDERFLOW     = 1 <<  7,  $/;"	e	enum:__anon2
DATA_DYNAMIC_GROW	bfci.h	/^    DATA_DYNAMIC_GROW        = 1 <<  8, $/;"	e	enum:__anon2
DATA_PENDING_IN	bfci.h	/^    DATA_PENDING_IN          = 1 <<  4,$/;"	e	enum:__anon2
DATA_PENDING_OUT	bfci.h	/^    DATA_PENDING_OUT         = 1 <<  3,$/;"	e	enum:__anon2
DEC	bfci.h	42;"	d
DO	bfci.h	46;"	d
EXIT	bfci.h	21;"	d
FAIL	bfci.h	18;"	d
FALSE	bfci.h	20;"	d
FILEFAIL	bfci.h	33;"	d
HEADERS	makefile	/^HEADERS = bfci.h # .h files$/;"	m
INC	bfci.h	41;"	d
LIFOPop	funcs.c	/^LIFOPop(ctxObjT Ctx){$/;"	f	file:
LIFOPush	funcs.c	/^LIFOPush(ctxObjT Ctx,$/;"	f	file:
LIFOPushNew	funcs.c	/^LIFOPushNew(ctxObjT Ctx,$/;"	f	file:
MAINSRC	makefile	/^MAINSRC = main.c # main source file, in most cases main.c$/;"	m
MVL	bfci.h	40;"	d
MVR	bfci.h	39;"	d
NASSERT	bfci.h	61;"	d
NDFINS	bfci.h	34;"	d
NDFUSAGE	bfci.h	35;"	d
NOLOOPEND	bfci.h	30;"	d
NOLOOPSTART	bfci.h	31;"	d
OBJS	makefile	/^OBJS = ${SRCS:.c=.o} $(MAINSRC:.c=.o)$/;"	m
OVERFLOW	bfci.h	28;"	d
PASTBOUNDS	bfci.h	36;"	d
PRINT_DIAGNOSTICS	bfci.h	/^    PRINT_DIAGNOSTICS        = 1 <<  9,$/;"	e	enum:__anon2
PROGRAM	makefile	/^PROGRAM = bfci # name of executable$/;"	m
SRCS	makefile	/^SRCS = funcs.c # .c files containing funcs$/;"	m
STDI	bfci.h	44;"	d
STDO	bfci.h	43;"	d
SUCCESS	bfci.h	17;"	d
StrToIns	funcs.c	/^StrToIns(ctxObjT Ctx, const char* string){$/;"	f
TCOLORS_H	tcolors.h	2;"	d
TEST	bfci.h	/^    TEST                     = 1 << 10,$/;"	e	enum:__anon2
TEST_STRICT	bfci.h	/^    TEST_STRICT              = 1 << 11,$/;"	e	enum:__anon2
TRUE	bfci.h	19;"	d
UNDERFLOW	bfci.h	29;"	d
WHILE	bfci.h	45;"	d
_ctxObjT	bfci.h	/^struct _ctxObjT {$/;"	s
_dataObjT	bfci.h	/^struct _dataObjT{$/;"	s
_insObjT	bfci.h	/^struct _insObjT{$/;"	s
_insSetT	bfci.h	/^struct _insSetT {$/;"	s
_stackCellT	bfci.h	/^struct _stackCellT {$/;"	s
_stackObjT	bfci.h	/^struct _stackObjT {$/;"	s
att	bfci.h	53;"	d
bool	bfci.h	/^typedef char bool;$/;"	t
cBLUE	tcolors.h	8;"	d
cERR	tcolors.h	11;"	d
cGREEN	tcolors.h	7;"	d
cNO	tcolors.h	5;"	d
cRED	tcolors.h	6;"	d
cWARN	tcolors.h	12;"	d
cWHITE	tcolors.h	9;"	d
cmd	bfci.h	/^typedef int    (*cmd)       (ctxObjT Ctx);$/;"	t
command	bfci.h	/^    cmd command;            \/* operation specific function to call *\/$/;"	m	struct:_insSetT
ctxFlags	bfci.h	/^} ctxFlags;$/;"	t	typeref:enum:__anon2
ctxObjT	bfci.h	/^typedef struct _ctxObjT     *ctxObjT;$/;"	t	typeref:struct:_ctxObjT
data	bfci.h	/^    dataObjT data;          \/* data object containing data over which instruction operate *\/$/;"	m	struct:_ctxObjT
dataObjT	bfci.h	/^typedef struct _dataObjT    *dataObjT;$/;"	t	typeref:struct:_dataObjT
decData	funcs.c	/^decData(ctxObjT Ctx){$/;"	f	file:
end	bfci.h	/^           end;             \/* index of closing bracket, as END in insSet *\/$/;"	m	struct:_stackCellT
execCtx	funcs.c	/^execCtx(ctxObjT Ctx){$/;"	f	file:
execIns	funcs.c	/^execIns(ctxObjT Ctx){$/;"	f	file:
false	bfci.h	/^    false = 0,$/;"	e	enum:__anon1
flags	bfci.h	/^    uint flags;             \/* flags containing states of machine *\/$/;"	m	struct:_ctxObjT
freeCtx	funcs.c	/^void freeCtx(ctxObjT Ctx){$/;"	f
freeData	funcs.c	/^freeData(dataObjT dataObj){$/;"	f	file:
freeIns	funcs.c	/^freeIns(insObjT insObj){$/;"	f	file:
freeStack	funcs.c	/^freeStack(stackObjT stackObj){$/;"	f	file:
getMatchingClosing	funcs.c	/^getMatchingClosing(size_t currindex, size_t lastindex, const char* string){$/;"	f	file:
getsrc	funcs.c	/^getsrc(const char *srcFilePath,$/;"	f	file:
incData	funcs.c	/^incData(ctxObjT Ctx){$/;"	f	file:
incPC	funcs.c	/^incPC(ctxObjT Ctx){$/;"	f	file:
index	bfci.h	/^    size_t index;           \/* index of current data block *\/$/;"	m	struct:_dataObjT
index	bfci.h	/^    size_t index;           \/* index of current instruction *\/$/;"	m	struct:_insObjT
initCtx	funcs.c	/^initCtx(const char* srcFilePath,$/;"	f
initData	funcs.c	/^dataObjT initData(size_t datalen){$/;"	f	file:
initIns	funcs.c	/^insObjT initIns(const char* srcFilePath){$/;"	f	file:
initStack	funcs.c	/^stackObjT initStack(){$/;"	f	file:
inpData	funcs.c	/^inpData(ctxObjT Ctx){$/;"	f	file:
ins	bfci.h	/^    insObjT ins;            \/* instruction object containing source code to execute *\/$/;"	m	struct:_ctxObjT
insObjT	bfci.h	/^typedef struct _insObjT     *insObjT;$/;"	t	typeref:struct:_insObjT
insSet	funcs.c	/^static const insSetT insSet[] = {$/;"	v	file:
insSetT	bfci.h	/^typedef struct _insSetT     insSetT;$/;"	t	typeref:struct:_insSetT
interpret	funcs.c	/^interpret(ctxObjT Ctx){$/;"	f
isBalanced	funcs.c	/^bool isBalanced(insObjT insObj){$/;"	f	file:
isInstruction	funcs.c	/^int isInstruction(char c) {$/;"	f	file:
isValidCtx	funcs.c	/^isValidCtx(ctxObjT Ctx){$/;"	f	file:
jmp	funcs.c	/^int jmp(insObjT insObj, size_t dest){$/;"	f	file:
jumped	bfci.h	/^    bool jumped;            \/* whether current instruction was jumped on by previous one *\/$/;"	m	struct:_insObjT
len	bfci.h	/^    size_t len;             \/* length of array *\/                   $/;"	m	struct:_dataObjT
len	bfci.h	/^    size_t len;             \/* length of array *\/                   $/;"	m	struct:_insObjT
len	bfci.h	/^    size_t len;             \/* number of cells in stack array *\/$/;"	m	struct:_stackObjT
loopBeg	funcs.c	/^loopBeg(ctxObjT Ctx){$/;"	f	file:
loopEnd	funcs.c	/^loopEnd(ctxObjT Ctx){$/;"	f	file:
main	main.c	/^int main(int argc, char **argv){$/;"	f
mvLeft	funcs.c	/^int mvLeft(ctxObjT Ctx){$/;"	f	file:
mvRight	funcs.c	/^int mvRight(ctxObjT Ctx){$/;"	f	file:
name	bfci.h	/^    const char *name;       \/* name of operation or NULL at end of object *\/$/;"	m	struct:_insSetT
opcode	bfci.h	/^    char opcode;            \/* identifier of specific operation *\/$/;"	m	struct:_insSetT
outData	funcs.c	/^outData(ctxObjT Ctx){$/;"	f	file:
printCtx	funcs.c	/^void printCtx(ctxObjT Ctx){$/;"	f
printData	funcs.c	/^void printData(ctxObjT Ctx){$/;"	f	file:
printFlags	funcs.c	/^void printFlags(ctxObjT Ctx){$/;"	f	file:
printHelp	funcs.c	/^void printHelp(){$/;"	f
printIns	funcs.c	/^void printIns(ctxObjT Ctx){$/;"	f	file:
printStack	funcs.c	/^void printStack(ctxObjT Ctx) {$/;"	f	file:
pushIns	funcs.c	/^int pushIns(char c, insObjT insObj){$/;"	f	file:
resetCtx	funcs.c	/^resetCtx(ctxObjT Ctx){$/;"	f	file:
resetData	funcs.c	/^resetData(dataObjT dataObj){$/;"	f	file:
resetIns	funcs.c	/^resetIns(insObjT insObj){$/;"	f	file:
resetStack	funcs.c	/^resetStack(stackObjT stackObj){$/;"	f	file:
srcpath	bfci.h	/^    char* srcpath;          \/* filepath of inputed BrainFuck source code *\/$/;"	m	struct:_insObjT
stack	bfci.h	/^    stackObjT stack;        \/* stack object used to store stacked bracket indexes *\/$/;"	m	struct:_ctxObjT
stackCellT	bfci.h	/^typedef struct _stackCellT  stackCellT;$/;"	t	typeref:struct:_stackCellT
stackObjT	bfci.h	/^typedef struct _stackObjT   *stackObjT;$/;"	t	typeref:struct:_stackObjT
start	bfci.h	/^    size_t start,           \/* index of opening bracket, as WHILE in insSet *\/$/;"	m	struct:_stackCellT
tape	bfci.h	/^    char *tape;             \/* instruction array *\/                              $/;"	m	struct:_insObjT
tape	bfci.h	/^    stackCellT *tape;       \/* stack array containing bracket pairs *\/$/;"	m	struct:_stackObjT
tape	bfci.h	/^    uchar *tape;    \/* data array *\/                              $/;"	m	struct:_dataObjT
test	funcs.c	/^test(void){$/;"	f
test_decData	funcs.c	/^test_decData(void){$/;"	f	file:
test_getMatchingClosing	funcs.c	/^test_getMatchingClosing(){$/;"	f	file:
test_incData	funcs.c	/^test_incData(void){$/;"	f	file:
test_jmp	funcs.c	/^test_jmp(){$/;"	f	file:
test_mvLeft	funcs.c	/^test_mvLeft(void){$/;"	f	file:
test_mvRight	funcs.c	/^test_mvRight(void){$/;"	f	file:
testfunc	bfci.h	/^typedef bool   (testfunc)   (void);$/;"	t
true	bfci.h	/^    true = 1$/;"	e	enum:__anon1
uchar	bfci.h	/^typedef unsigned char uchar;$/;"	t
uint	bfci.h	/^typedef unsigned int uint;$/;"	t
usedlen	bfci.h	/^    size_t usedlen;         \/* furthest visited array index + 1*\/                 $/;"	m	struct:_dataObjT
usedlen	bfci.h	/^    size_t usedlen;         \/* furthest visited array index + 1*\/                 $/;"	m	struct:_insObjT
