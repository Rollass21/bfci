!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALLOCFAIL	bfci.h	22;"	d
ALLOCJMP	bfci.h	14;"	d
BFCI_H	bfci.h	2;"	d
BIT_SET_FALSE	bfci.h	40;"	d
BIT_SET_TRUE	bfci.h	39;"	d
BIT_TOGGLE	bfci.h	38;"	d
CC	makefile	/^CC = gcc # compiler used: gcc$/;"	m
CFLAGS	makefile	/^CFLAGS = -O0 -ggdb -Wall #-Werror$/;"	m
CHECK_BRACKETS	bfci.h	/^    CHECK_BRACKETS           = 1 << 9,$/;"	e	enum:__anon1
CTX_COMPLETED	bfci.h	/^    CTX_COMPLETED            = 1 << 2,$/;"	e	enum:__anon1
CTX_RUNNING	bfci.h	/^    CTX_RUNNING              =      1,$/;"	e	enum:__anon1
DATAMAX	bfci.h	12;"	d
DATAMAXLEN	bfci.h	15;"	d
DATAMIN	bfci.h	13;"	d
DATA_ALLOW_LOOPED	bfci.h	/^    DATA_ALLOW_LOOPED        = 1 << 5,  $/;"	e	enum:__anon1
DATA_ALLOW_OVERFLOW	bfci.h	/^    DATA_ALLOW_OVERFLOW      = 1 << 6,  $/;"	e	enum:__anon1
DATA_ALLOW_UNDERFLOW	bfci.h	/^    DATA_ALLOW_UNDERFLOW     = 1 << 7,  $/;"	e	enum:__anon1
DATA_DYNAMIC_GROW	bfci.h	/^    DATA_DYNAMIC_GROW        = 1 << 8, $/;"	e	enum:__anon1
DATA_PENDING_IN	bfci.h	/^    DATA_PENDING_IN          = 1 << 4,$/;"	e	enum:__anon1
DATA_PENDING_OUT	bfci.h	/^    DATA_PENDING_OUT         = 1 << 3,$/;"	e	enum:__anon1
DEC	bfci.h	32;"	d
END	bfci.h	36;"	d
FAIL	bfci.h	9;"	d
FALSE	bfci.h	11;"	d
FILEFAIL	bfci.h	23;"	d
HEADERS	makefile	/^HEADERS = bfci.h # .h files$/;"	m
INC	bfci.h	31;"	d
MAINSRC	makefile	/^MAINSRC = main.c # main source file, in most cases main.c$/;"	m
MVL	bfci.h	30;"	d
MVR	bfci.h	29;"	d
NDFINS	bfci.h	24;"	d
NDFUSAGE	bfci.h	25;"	d
NOLOOPEND	bfci.h	20;"	d
NOLOOPSTART	bfci.h	21;"	d
OBJS	makefile	/^OBJS = ${SRCS:.c=.o} $(MAINSRC:.c=.o)$/;"	m
OVERFLOW	bfci.h	18;"	d
PASTBOUNDS	bfci.h	26;"	d
PROGRAM	makefile	/^PROGRAM = bfci # name of executable$/;"	m
SPop	funcs.c	/^SPop(stackObjT stack){$/;"	f	file:
SPush	funcs.c	/^SPush(stackObjT stack, size_t startindex, size_t endindex){$/;"	f	file:
SRCS	makefile	/^SRCS = funcs.c # .c files containing funcs$/;"	m
STDI	bfci.h	34;"	d
STDO	bfci.h	33;"	d
SUCCESS	bfci.h	8;"	d
StrToIns	funcs.c	/^StrToIns(ctxObjT Ctx, const char* string){$/;"	f
TRUE	bfci.h	10;"	d
UNDERFLOW	bfci.h	19;"	d
WHILE	bfci.h	35;"	d
_ctxObjT	bfci.h	/^struct _ctxObjT {$/;"	s
_dataObjT	bfci.h	/^struct _dataObjT{$/;"	s
_insObjT	bfci.h	/^struct _insObjT{$/;"	s
_insSetT	bfci.h	/^struct _insSetT {$/;"	s
_stackCellT	bfci.h	/^struct _stackCellT {$/;"	s
_stackObjT	bfci.h	/^struct _stackObjT {$/;"	s
bool	bfci.h	/^typedef int bool;$/;"	t
cmd	bfci.h	/^typedef int    (*cmd)       (ctxObjT Ctx, uint flags);$/;"	t
command	bfci.h	/^    cmd command;            \/* operation specific function to call *\/$/;"	m	struct:_insSetT
ctxFlags	bfci.h	/^} ctxFlags;$/;"	t	typeref:enum:__anon1
ctxObjT	bfci.h	/^typedef struct _ctxObjT     *ctxObjT;$/;"	t	typeref:struct:_ctxObjT
data	bfci.h	/^    dataObjT data;          \/* data object containing data over which instruction operate *\/$/;"	m	struct:_ctxObjT
dataObjT	bfci.h	/^typedef struct _dataObjT   *dataObjT;$/;"	t	typeref:struct:_dataObjT
decData	funcs.c	/^decData(ctxObjT Ctx,$/;"	f	file:
end	bfci.h	/^           end;             \/* index of closing bracket, as END in insSet *\/$/;"	m	struct:_stackCellT
execute	funcs.c	/^int execute(ctxObjT Ctx){$/;"	f	file:
flags	bfci.h	/^    uint flags;             \/* flags containing states of machine *\/$/;"	m	struct:_ctxObjT
freeCtx	funcs.c	/^void freeCtx(ctxObjT Ctx){$/;"	f
getMatchingEnd	funcs.c	/^getMatchingEnd(insObjT insObj){$/;"	f	file:
getsrc	funcs.c	/^getsrc(const char *srcFilePath,$/;"	f	file:
incData	funcs.c	/^incData(ctxObjT Ctx,$/;"	f	file:
index	bfci.h	/^    size_t index;           \/* index of current data block *\/$/;"	m	struct:_dataObjT
index	bfci.h	/^    size_t index;           \/* index of current instruction *\/$/;"	m	struct:_insObjT
initCtx	funcs.c	/^initCtx(const char* srcFilePath,$/;"	f
initData	funcs.c	/^dataObjT initData(size_t datalen){$/;"	f	file:
initIns	funcs.c	/^insObjT initIns(const char* srcFilePath){$/;"	f	file:
initStack	funcs.c	/^stackObjT initStack(){$/;"	f	file:
inpData	funcs.c	/^inpData(ctxObjT Ctx,$/;"	f	file:
ins	bfci.h	/^    insObjT ins;            \/* instruction object containing source code to execute *\/$/;"	m	struct:_ctxObjT
insObjT	bfci.h	/^typedef struct _insObjT    *insObjT;$/;"	t	typeref:struct:_insObjT
insSet	funcs.c	/^static const insSetT insSet[] = {$/;"	v	file:
insSetT	bfci.h	/^typedef struct _insSetT     insSetT;$/;"	t	typeref:struct:_insSetT
isInstruction	funcs.c	/^int isInstruction(int c) {$/;"	f	file:
isValidCtx	funcs.c	/^isValidCtx(ctxObjT Ctx){$/;"	f	file:
jmp	funcs.c	/^unsigned int jmp(insObjT insObj, size_t dest){$/;"	f	file:
len	bfci.h	/^    size_t len;             \/* length of array *\/                   $/;"	m	struct:_dataObjT
len	bfci.h	/^    size_t len;             \/* length of array *\/                   $/;"	m	struct:_insObjT
len	bfci.h	/^    size_t len;             \/* number of cells in stack array*\/$/;"	m	struct:_stackObjT
loopBeg	funcs.c	/^loopBeg(ctxObjT Ctx,$/;"	f	file:
loopEnd	funcs.c	/^loopEnd(ctxObjT Ctx,$/;"	f	file:
main	main.c	/^int main(int argc, char **argv){$/;"	f
mvLeft	funcs.c	/^int mvLeft(ctxObjT Ctx,$/;"	f	file:
mvRight	funcs.c	/^int mvRight(ctxObjT Ctx,$/;"	f	file:
name	bfci.h	/^    const char *name;       \/* name of operation or NULL at end of object *\/$/;"	m	struct:_insSetT
opcode	bfci.h	/^    char opcode;            \/* identifier of specific operation *\/$/;"	m	struct:_insSetT
outData	funcs.c	/^outData(ctxObjT Ctx,$/;"	f	file:
printCtx	funcs.c	/^void printCtx(ctxObjT Ctx){$/;"	f
printData	funcs.c	/^void printData(ctxObjT Ctx){$/;"	f	file:
printFlags	funcs.c	/^void printFlags(ctxObjT Ctx){$/;"	f	file:
printHelp	funcs.c	/^void printHelp(){$/;"	f
printIns	funcs.c	/^void printIns(ctxObjT Ctx){$/;"	f	file:
printStack	funcs.c	/^void printStack(ctxObjT Ctx) {$/;"	f	file:
pushIns	funcs.c	/^int pushIns(int c, insObjT insObj){$/;"	f	file:
srcpath	bfci.h	/^    char* srcpath;          \/* filepath of inputed BrainFuck source code *\/$/;"	m	struct:_insObjT
stack	bfci.h	/^    stackObjT stack;        \/* stack object used to store stacked bracket indexes *\/$/;"	m	struct:_ctxObjT
stackCellT	bfci.h	/^typedef struct _stackCellT  stackCellT;$/;"	t	typeref:struct:_stackCellT
stackObjT	bfci.h	/^typedef struct _stackObjT  *stackObjT;$/;"	t	typeref:struct:_stackObjT
start	bfci.h	/^    size_t start,           \/* index of opening bracket, as WHILE in insSet *\/$/;"	m	struct:_stackCellT
tape	bfci.h	/^    stackCellT *tape;       \/* stack array containing bracket pairs *\/$/;"	m	struct:_stackObjT
tape	bfci.h	/^    unsigned char *tape;    \/* data array *\/                              $/;"	m	struct:_dataObjT
tape	bfci.h	/^    unsigned char *tape;    \/* instruction array *\/                              $/;"	m	struct:_insObjT
uint	bfci.h	/^typedef unsigned int uint;$/;"	t
usedlen	bfci.h	/^    size_t usedlen;         \/* furthest visited array index *\/                 $/;"	m	struct:_dataObjT
usedlen	bfci.h	/^    size_t usedlen;         \/* furthest visited array index *\/                 $/;"	m	struct:_insObjT
